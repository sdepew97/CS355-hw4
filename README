Assumptions when Coding:
* In the non-preemptive scheduling algorithms, FIFO and SJF, when a new thread is created, it is blocked. If we do not join the thread,
then it remains blocked and will never run. Only upon a thread_join is the thread able to run and the scheduler called.

Notes:
* My log is found in log.txt
* I ran the Ziting tests and took care of the deadlocking cases by returning errors for these cases; I didn't want to deadlock, so I addressed the issues and simply did not permit the joins to occur

Known Bugs/Notes:
* My yielding is not working 100% correctly for threads; I ended up having to sigprocmask too much of my code to allow successful interleaving to occur
* I have a ton of valgrind errors
* I am unable to free the context memory
* Odd error relating to priority scheduling where I run for shorter time than expected, but thread function adequately runs and reaches the end of the run
* There was one time I ran valgrind and got a segfault. I tried to recreate the error to no avail. I am wondering if there is a minor race condition that occured. I
knew about this and attempted to fix it, but was unable to recreate the issue. So, I am recording it here. This was running in Priority scheduling mode.
* Small memory leaks with TCB and UContexts
* Weird bug about printing and swapping for Prority on one test (Rachel was sent a screen shot)
* I was unable to figure out how to break my code in userthread.c into multiple .h files. If I could have done so, I would have done ___, ___, and ____.
* I am not 100% certain the ratio on my scheduler is correct. I followed your advice, but after running
Eileen's test I am not sure I have the proper ratio. I think I do, but I wanted to document the
possibility it was not 100% correct.
* I kept getting a persistent error with jiaping's wjp_priority_yield_same test and wjp_test_fifo_basic where I had a Conditional jump or move depending upon an uninitialized value error
* I decided on different behavior than jiaping for wjp_test_invalid_join where an attempted join was valid on a thread that had already
terminated that was attempting to be joined
*